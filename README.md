<h1 align="center"> Вопросы и ответы к интервью на позицию AQA </h1>

<details>
    <summary>Теория тестирования</summary>
        <h3>Виды тестирования</h3>
            Функциональное; Нефункциональное
            Виды функционального тестирования
            Модульное; Интеграционное; Системное; Смок тест; Регрессионное, Позитивное, Тестирование методом: белого, серого, черного ящика; Негативное
            Приемочное - это формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса;
            Альфа-тестирование — ранняя версия программного продукта, тестирование которой проводится внутри организации-разработчика;
            Бета тестирвоание — практически готовое ПО, выпускаемое для ограниченного количества пользователей
            Виды нефункционального тестирования
            Нагрузочное тестирование - имитирующее работу определенного количества бизнес пользователей на каком-либо общем ресурсе
            Стессовое тестирование - надёжность и устойчивость системы в условиях превышения пределов нормального функционирования
            Тестирование на отказ и восстановление
            <h3>Техники тест дизайна</h3>
                Эквивалентное разбиение - техника разбиения на группы эквивалентных по своему влиянию значений 
                Анализ граничных значений - проверка граничащих значений вводных данных
                Предугадывание ошибки - на основании знаний системы и спецификаций тестер предугадывает возможный дефект при опр вводных условиях
                Причина/Следствие - Подразумевает ввод условий для  получения ответа от системы
                Сценарий пользования - описанный сценарий пользования (взаимодействия пользователя и системы)
                Попарное тестирвоание - выполние всех возможных отдельных комбинаций каждой пары входных параметров
                Таблица принятия решений - таблица с условиями и различными комбинациями, а так же результатом на каждый кейс
            <h3>Пирамида тестирования</h3>
                Модульное, интеграционное, системное, приемочное
            <h3>Принципы тестирования</h3>      
                    Принципы тестирования: Тестирование демонстрирует наличие дефектов а не их отсутствие, Исчерпывающее тестирование недостижимо,
                    Раннее тестирование сохраняет время и деньги, Кластеризация дефектов, Парадокс пестицида, Тестирование зависит от контекста,
                    Заблуждение об отсутствии ошибок
            <h3>Верификация и валидация</h3>
                    Верификация - было ли программное обеспечение создано в соответствии с требованиями или нет
                    этот процесс включает в себя ревью, пошаговое руководство и инспекция
                    Валидация - действительно ли программный продукт соответствует точным потребностям заказчика или нет
                    этот процесс вклчюает в себя модульное тестирование, интеграционное тестирование, системное тестирование и 
                    пользовательское приемочное тестирование.
            <h3>Тестирование программного обеспечения (Software Testing)</h3>
                    Тестирование программного обеспечения (Software Testing) - проверка соответствия между реальным и ожидаемым поведением программы
                    Цели тестирования:
                        1. Предоставление актуальной информации о состоянии продукта на данный момент.
                        2. Проверка на то, а все ли требования выполнены
                        3. Предотвращение дефектов (на ранних стадиях тесторование документации)
                        4. Повышение качества продукта
            <h3>Виды ошибок</h3>
                    error - ошибка пользователя, bug - ошибка программиста, failure - сбой в работе компонента
            <h3>Жизненный цикл разработки и тестирования ПО</h3>
                    SDLC - Ж/Ч разработки ПО (Идея, требования, дизайн, разработка, тест, ввод в работу, поддержка, вывод из работы)
                    STLC - Ж/Ч тестирования ПО (требования, планирвоание, тест кейсы, тестовая среда, тестирование)
            <h3>Жизненный цикл бага</h3>
                    Жизненный цикл бага - это стадии, которые проходит ошибка с начала своего существования и до ее полного разрешения.
                    Стадии жизненного цикла: дефект обнаружен, дефект зарегистрирован, работа над дефектом, перепроверка дефекта, 
                    дефект закрыт/работа над дефектом


</details>
<details>
    <summary>Web (front and back)</summary>
    <h3></h3>
    <p></p>
</details>


<details>
    <summary>Java Core</summary>
        <h3>Java коллекции</h3>
            Java коллекции - набор каких-либо объектов, которые хранятся внутри коллекции
            ????????????
             Интерфейсы:
            List - это упорядоченный список с индексами в котором допускаются дубли
            Set - неупорядоченный список уникальных элементов
            Map - состоит из пар ключ(уникальный) значение(может повторяться)
            Queue - для хранения элементов в порядке, нужном для их обработки
            Deque - двухсторонняя очередеть
            Классы:
            ArrayList - это список на основе массива (следует использовать, когда в приоритете доступ по индексу)
            LinkedList - связанный список на основе элементов и связи между ними (удобен когда важнее быстродействие операций вставки/удаления)
            HashSet -  хеш таблица для хранения допускает хранение только отдельных элементов
            HashMap - хеш таблица в которой есть пары ключ и значение 
        <h3>Эксепшены</h3>
            Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable, потомками которого являются классы 
            Exception и Error
            Error - возникают например, когда закончилась память (OutOfmemory), StackOverflow(метод бесконечно вызывает сам себя)
            Exeptions:
            проверяемые(Класс exceptions) - те, про которые компилятор джавы знает, и знает в каких ситуациях они могут возникнуть
            (ClassNotFound, NoSuchMethod, FileNotFound)
            непроверяемые(Класс RuntimeExceptions) - ошибка во время выполнения программы, возникают если разработчик допустил 
            невыполнимую операцию
            (IndexOutOfBounds, NullPointer, IllegarArgument)
            try {блок кода, в котором реализованна логика программы}, catch {ловим проверяемые ексепшены (ArithmeticException)},
            finally {блок кода, реализуется после try-catch, выполняется независимо было ли исключение выброшено или нет}
            resources - необходим для того, чтобы решать проблему с вызовом close() при работе с внешними ресурсами
            (при работе с внешними ресурсами может возникнуть эксепшн и close добавленный в ручную не сработает)
        <h3>Принципы проектирования</h3>
            SOLID
            1. Принцип единственной ответственности - класс должен делать только одно дело
            2. Принцип открытости-закрытости - классы были открыты для расширения(интерфейсы, абстрактные классы), но закрыты для изменения внутреннего кода.
            3. Принцип подстановки Лисков - Наследующий класс должен дополнять, а не замещать поведение базового класса
            4. Принцип разделения интерфейса - много клиентоориентированных интерфейсов лучше, чем один интерфейс общего назначения
            5. Принцип инверсии зависимостей - наши классы должны зависеть от интерфейсов или абстрактных классов, а не от конкретных классов и функций.
            ??????????????????????? KISS and DRY
        <h3>Stream api</h3>
            это способ работать со структурами данных, чаще всего с коллекциями
            два типа методов конвеерные(sorted, limit, filter, skip) и терминальные(collect, forEach, count)
            ???????????????????????
        <h3>ООП</h3>
        <h3>PageObject</h3>
        <h3>Типы данных</h3>
        <h3>Сериализация</h3>
            Сериализация - это процесс сохранения объекта в байты
            Десериализация - процесс восстановления из байт
            За эти процессы отвечает интерфейс serializable, это все необходимо для общения в удобном формате между программами
        <h3>Рефлексия</h3>
            Рефлексия - это механизм изучения информации о программе при ее выполнении (ее методы, конструкторы, поля)
            Рекурсивные функции в java – это функции, которые вызывают сами себя
        <h3>Ковариантность и контравариантность</h3>
            Ковариантность и контравариантность описывают совместимость типов по отношению базового класса с наследником
            Ковариантность - перенос наследования исходных типов на наследуемые от них типы в прямом порядке
            есть метод, который принимает список девайсов, клавиатура является наследником от девайсов, в этот метод можно поместить список клавиатур
            Контрвариантность - перенос наследования исходных типов на наследуемые от них типы в обратном порядке
            есть метод, который как-то взаимодействует со списком клавиатур, есть список, который взаимодействует в целом с девайсами(супер класс),
            в этот метод(взаимодействия со списком клавиатур) мы можем поместить список взаимодействия с девайсами
        <h3>Сборщики мусора</h3>
            4 типа ссылок в java - StrongReference, WeakReference, SoftReference, PhantomReference (различия между ними в том, как будет работать 
            с ними сборщик мусора) Strong - пока не null не очищается сборщиком, soft - очищаются в случае необходимости, weak - 
            очищаются когда не используются, фантомные - объект уже признан мусором, финализирован и находится в процессе зачистки
</details>



<details>
    <summary>Docker</summary>
</details>
<details>
    <summary>Git</summary>
</details>
<details>
    <summary>Frameworks (Selenium/Selenide and JUnit etc)</summary>
</details>
<details>
    <summary>Базовые знания Linux администрирования</summary>
</details>
